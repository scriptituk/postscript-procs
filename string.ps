% PostScript String Procedures
% by scriptit.co.uk

% constants
/WHITESPACE ( \n\r\t\b\f\000) def % whitespace chars (from PHP)
/REALNUMBER (0123456789.Ee+-) def % real (and integer) signed number chars

% get string value of integer
/chr {
	16#FF and 1 string exch 1 index exch 0 exch put
} bind def

% get integer value of character
/ord {
	0 get
} bind def

% get string hash (32 bit unsigned)
% djb2 algorithm by Dan Bernstein (xor variant), see http://www.cse.yorku.ca/~oz/hash.html
% <str> hash <hash>
/hash {
	5381 % hash
	exch {
		exch
		dup 5 bitshift iadd32 xor % hash *= 33 ^ char
	} forall
} bind def

% convert any to string
/cvas {
	dup type /stringtype ne { dup type /nametype eq { dup length }{ 20 } ifelse string cvs } if
} bind def

% concatenate two strings
% <str1> <str2> cat <str1str2>
/cat {
	exch
	dup length 2 index length add string
	dup dup 5 2 roll
	copy length exch putinterval
} bind def

% concatenate two objects
% <any> <any> concat2 <string>
/concat2 {
	cvas exch cvas exch cat
} bind def

% concatenate array of objects with separator
% <[any]> <separator> concatas <string>
/concatas {
	exch [ exch { cvas } forall ] exch % any to string
	2 copy length exch length 1 sub mul % separator space
	2 index { length add } forall % strings space
	string % result
	dup /NullEncode filter % write as a file
	3 -1 roll
	()
	5 -1 roll
	{
		3 index 2 index writestring
		3 index exch writestring
		pop dup
	} forall
	pop pop
	closefile
} bind def

% concatenate array of objects
% <[any]> concata <string>
/concata {
	() concatas
} bind def

% strip whitespace from beginning and end of string
% <string> trim <string>
/trim {
	//WHITESPACE exch
	dup length 1 sub exch 0
	0 1 4 index {
		2 index exch 1 getinterval
		4 index exch search { pop pop pop 1 add }{ pop exit } ifelse
	} for
	exch 3 -1 roll
	dup -1 4 index {
		2 index exch 1 getinterval
		4 index exch search { pop pop pop 1 sub }{ pop exit } ifelse
	} for
	exch 3 1 roll
	1 add 1 index sub getinterval
	exch pop
} bind def

% split string by given substring
% <string> <seek> split <array>
/split {
	[ 3 1 roll { search { 3 1 roll }{ exit } ifelse } loop ]
} bind def

% split CSV string into array
% <string> csv <array>
/csv {
	(,) split
} bind def

% convert to lower case (ASCII only)
% <string> tolower <string>
/tolower {
	dup length string copy
	0 1 2 index length 1 sub {
		2 copy get
		dup dup 65 ge exch 90 le and { 32 add 3 copy put } if pop
		pop
	} for
} bind def

% convert to upper case (ASCII only)
% <string> toupper <string>
/toupper {
	dup length string copy
	0 1 2 index length 1 sub {
		2 copy get
		dup dup 97 ge exch 122 le and { 32 sub 3 copy put } if pop
		pop
	} for
} bind def

% read inline heredoc up to marker string e.g. (%EOD)
% <EODString> heredoc <string>
/heredoc {
	currentfile exch 0 exch /SubFileDecode filter 65535 string readstring pop
} bind def

% crunch postscript code string
% <ps> crunchps <string>
/crunchps {
	dup length string copy
	0 % index
	false % insert space
	false % in comment
	3 index {
		{ % case stmt
			dup 10 eq { pop pop pop true false exit } if % newline
			1 index { pop exit } if % in comment
			dup 37 eq { pop pop true exit } if % percent
			dup 32 le { pop pop pop true false exit } if % whitespace
			exch pop exch 2 index 0 ne and { % space?
				2 index 2 index 1 sub get % last saved char
				dup 123 ne exch dup 91 ne exch 60 ne and and % last != { or [ or <
				1 index % this char
				dup 125 ne exch dup 93 ne exch 62 ne and and % this != } or ] or >
				and { 2 index 2 index 32 put exch 1 add exch } if % save space
			} if
			3 copy put pop % save
			1 add false false
			exit
		} loop
	} forall
	pop pop
	0 exch getinterval
} bind def

% fold lines to 80 characters max without word breaks
% <string> fold80 <string>
/fold80 {
	0
	{
		80 add
		2 copy exch length ge { exit } if
		{
			2 copy get 32 eq {
				2 copy 10 put exit % space -> newline
			}{
				1 sub
			} ifelse
		} loop
	} loop
	pop
} bind def

% convert int to octal escape string
% <int> octal8 <string>
/octal8 {
	16#FF and
	4 string (\\00) 1 index copy pop
	dup 3 -1 roll
	8 3 string cvrs
	dup length neg 3 and
	exch putinterval
} bind def

% convert int to two octal escape string
% <int> octal16 <string>
/octal16 {
	dup -8 bitshift octal8 exch octal8 cat
} bind def

% convert UTF-8 to UTF-16BE
% assumes valid UTF-8
% see http://tidy.sourceforge.net/cgi-bin/lxr/source/src/utf8.c
% and https://en.wikipedia.org/wiki/UTF-8#Codepage_layout
% surrogate pairs result for code points > 16#FFFF (Supplementary Characters) - should map to .notdef
% <utf8 string> utf8toutf16be <utf16 string>
/utf8toutf16be {
	[ exch
		0 % # continuation bytes
		exch {
			exch
			dup 0 eq { % leading byte in sequence
				pop
				dup 16#BF le {
					16#7F and 0 % no continuation
				}{
					dup 16#DF le {
						16#1F and 1 % 1 continuation byte
					}{
						dup 16#EF le {
							16#0F and 2 % 2 continuation bytes
						}{
							16#07 and 103 % 3 continuation bytes; surrogates marker
						} ifelse
					} ifelse
				} ifelse
			}{ % continuation
				1 sub
				3 1 roll
				16#3F and
				exch 6 bitshift or
				exch
				dup 100 eq { % surrogates
					pop
					16#10000 sub
					dup -10 bitshift 16#3FF and 16#D800 or % high surrogate
					exch 16#3FF and 16#DC00 or % low surrogate
					0
				} if
			} ifelse
		} forall
		pop
	]
	int2str16
} bind def

% convert UCS-2 to UTF-8
% see http://tidy.sourceforge.net/cgi-bin/lxr/source/src/utf8.c
% <ucs2 string> ucs2toutf8 <utf8 string>
/ucs2toutf8 {
	dup length dup add array exch 0 exch
	0 % ucs2 index
	{
		2 copy exch length ge { exit } if
		2 copy 2 copy 1 add get 3 1 roll get 8 bitshift or
		[ exch
			dup 16#7F gt {
				dup 16#7FF le {
					dup -6 bitshift 16#C0 or
					exch 16#3F and 16#80 or
				}{
					dup -12 bitshift 16#E0 or
					exch dup -6 bitshift 16#3F and 16#80 or
					exch 16#3F and 16#80 or
				} ifelse
			} if
		]
		4 -1 roll exch
		4 index 2 index 2 index putinterval
		length add 3 1 roll
		2 add
	} loop
	pop pop
	0 exch getinterval
	dup length string exch
	0 exch {
		3 copy put pop
		1 add
	} forall
	pop
} bind def

% convert UTF16BE string to array of 2 byte char strings
% <string> utf16chars <array>
/utf16chars {
	dup length 2 idiv array % UTF16BE char strings
	exch 0 % index
	exch {
		2 index 2 index get dup null eq {
			pop
			2 index 2 index 2 string dup 0 6 -1 roll put put
		}{
			exch 1 exch put
			1 add
		} ifelse
	} forall
	pop
} bind def

% convert array of 2 byte char strings to UTF16BE string
% <array> utf16string <string>
/utf16string {
	dup length dup add string % dest
	exch 0 % index
	exch {
		3 copy putinterval pop
		2 add
	} forall
	pop
} bind def

% convert UTF16 string to integer array
% <string> str2int16 <array>
/str2int16 {
	dup length 2 idiv array
	exch 0 % index
	exch {
		2 index 2 index get dup null eq {
			pop
			8 bitshift 3 copy put pop
		}{
			or 3 copy put pop
			1 add
		} ifelse
	} forall
	pop
} bind def

% convert integer array to UTF16 string
% <string> utf16ints <array>
/int2str16 {
	dup length 1 bitshift string
	exch 0 % index
	exch {
		3 copy -8 bitshift 16#FF and put
		exch 1 add exch
		3 copy 16#FF and put
		pop
		1 add
	} forall
	pop
} bind def

% encode dictionary or array as a JSON data-interchange string
% (simple implementation, outputs UTF8 JSON)
% <any> jsonencode <string>
/jsonencode {
	[ exch
	dup type { % case stmt
		dup /dicttype eq {
			pop
			({) exch {
				2 index ({) ne { (,) 3 1 roll } if
				exch (") exch (":) 4 -1 roll jsonencode
			} forall
			(})
			exit
		} if
		dup dup /arraytype eq exch /packedarraytype eq or {
			pop
			([) exch {
				1 index ([) ne { (,) exch } if
				jsonencode
			} forall
			(])
			exit
		} if
		dup /nametype eq { pop cvas /stringtype } if % fall through
		dup /stringtype eq {
			pop
			dup length 2 bitshift string 0
			2 copy (") putinterval 1 add
			3 -1 roll {
				chr {
					dup (") eq { pop (\\") exit } if
					dup (\\) eq { pop (\\\\) exit } if
					dup (/) eq { pop (\\/) exit } if
					dup (\b) eq { pop (\\b) exit } if
					dup (\f) eq { pop (\\f) exit } if
					dup (\n) eq { pop (\\n) exit } if
					dup (\r) eq { pop (\\r) exit } if
					dup (\t) eq { pop (\\t) exit } if
					dup ord dup 16#1F le exch 16#7F eq or { % control char
						ord
						(\\u00) 1 index 16 lt { (0) cat } if
						exch 16 2 string cvrs cat
						exit
					} if
					exit % assume UTF8/ASCII
				} loop
				3 copy putinterval length add
			} forall
			2 copy (") putinterval 1 add
			0 exch getinterval
			exit
		} if
		dup /integertype eq { pop exit } if
		dup /realtype eq { pop exit } if
		dup /booleantype eq { pop exit } if
		dup /nulltype eq { pop pop (null) exit } if
		pop pop exit % invalid
	} loop
	] concata
} bind def

% decode JSON data-interchange string
% (simple implementation, assumes valid UTF8 JSON)
% <string> jsondecode <any>
/jsondecode {
	/_jsonskip { 1 index length 1 index sub getinterval } bind def
	mark exch
	{ % case stmt
		dup length 0 eq { pop exit } if % all parsed
		dup 0 1 getinterval { % case stmt
			//WHITESPACE 1 index search { % whitespace
				pop pop pop
				pop
				1 exit
			}{
				pop
			} ifelse
			dup ([) eq { % array
				pop
				[ exch
				1 exit
			} if
			dup (]) eq { % array end
				pop
				counttomark 1 add 1 roll ] exch
				1 exit
			} if
			dup ({) eq { % object
				pop
				<< exch
				1 exit
			} if
			dup (}) eq { % object end
				pop
				counttomark 1 add 1 roll >> exch
				1 exit
			} if
			dup (:) eq { % name/value separator
				pop
				exch cvn exch
				1 exit
			} if
			dup (,) eq { % separator
				pop
				1 exit
			} if
			dup (") eq { % string
				pop
				1 _jsonskip
				0 {
					2 copy 1 getinterval
					dup (") eq { pop exit } if
					dup (\\) eq {
						pop
						2 copy 0 exch getinterval
						2 index 2 index 1 add 1 getinterval {
							dup (b) eq { pop (\b) exit } if
							dup (f) eq { pop (\f) exit } if
							dup (n) eq { pop (\n) exit } if
							dup (r) eq { pop (\r) exit } if
							dup (t) eq { pop (\t) exit } if
							dup (u) eq { % \uXXXX
								pop
								[
									(16#) 4 index 4 index 2 add 4 getinterval cat
									cvx exec
								] int2str16 ucs2toutf8
								3 -1 roll 4 add 3 1 roll
								exit
							} if
							exit % keep other chars
						} loop
						cat
						dup length
						exch 4 2 roll
						2 add _jsonskip % \ and next
						cat exch
					}{
						pop
						1 add % next char
					} ifelse
				} loop
				2 copy 0 exch getinterval
				3 1 roll
				1 add exit
			} if
			dup (f) eq { % false
				pop
				false exch
				5 exit
			} if
			dup (t) eq { % true
				pop
				true exch
				4 exit
			} if
			dup (n) eq { % null
				pop
				null exch
				4 exit
			} if
			{ % number
				pop
				0 {
					2 copy exch length eq { exit } if
					2 copy 1 getinterval
					//REALNUMBER exch search {
						pop pop pop
					}{
						pop exit
					} ifelse
					1 add
				} loop
				2 copy 0 exch getinterval
				cvx exec
				3 1 roll
				exit
			} exec
		} loop
		_jsonskip
	} loop
	counttomark 0 eq { null } if % null if empty
	exch pop
} bind def

% translate string (char ints) to BMP PUA if symbol font
% <char array> <mincid> symboloffset <cid array>
/symboloffset {
	16#F000 and dup 16#E000 ge { % offset is 16#E000 or 16#F000
		exch
		0 1 2 index length 1 sub {
			2 copy get
			dup dup 5 index lt exch 16#20 ge and { % < PUA, > ctrl codes
				3 index add 2 index 3 1 roll put
			}{
				pop pop
			} ifelse
		} for
		exch
	} if
	pop
} bind def
